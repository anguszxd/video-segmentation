#include <stdio.h>
#include <iostream>
#include <cmath>
#include <cstdlib>
#include <algorithm>
#include <vector>
#include "opencv2/photo.hpp"
#include "opencv2/objdetect/objdetect.hpp"
#include "opencv2/highgui/highgui.hpp"
#include "opencv2/imgproc/imgproc.hpp"
#include <opencv2/video/background_segm.hpp>

#define END 50
/// Global Variables
int DELAY_CAPTION = 1500;
int DELAY_BLUR = 100;
int MAX_KERNEL_LENGTH = 31;

using namespace std;
using namespace cv;

int absolute_val(int a)
{
	if(a>0)
	{
		return a;
	}
	else 
	{
		return -1*a;
	}
}


int main(int argc,char* argv[])
{
    double alpha = 1.0; /**< Simple contrast control [1.0-3.0] */
    int beta = 0;  /**< Simple brightness control [0-100]*/
    bool bSuccess;

    Mat fgMaskMOG, bkMaskMOG; //fg mask generated by MOG method
    Ptr<BackgroundSubtractorMOG2> pMOG; //MOG2 Background subtractor

    HOGDescriptor hog;
    hog.setSVMDetector(HOGDescriptor::getDefaultPeopleDetector());

    //create Background Subtractor objects
    pMOG = createBackgroundSubtractorMOG2(); //MOG2 approach

    VideoCapture cap(argv[1]); // open the video camera no. 0

    if (!cap.isOpened())  // if not success, exit program
    {
        cout << "Cannot open the video cam" << endl;
        return -1;
    }

    double dWidth = cap.get(CV_CAP_PROP_FRAME_WIDTH); //get the width of frames of the video
    double dHeight = cap.get(CV_CAP_PROP_FRAME_HEIGHT); //get the height of frames of the video

    cout << "Frame size : " << dWidth << " x " << dHeight << endl;

    Mat image,image_seg;
    
    cap.read(image);
    resize(image,image,Size(image.cols/3,image.rows/3));
    image_seg = image;

    cvtColor(image,image,CV_BGR2GRAY);

    //equalizeHist(image,image1);
    cout<<image.channels()<<endl;

    while (1)
    {
        int K=0;
        Mat frame,diff,raw_frame;
        int di1,di2,di3;

        if (!(bSuccess = cap.read(frame))) //if not success, break loop
        {
            cout << "Cannot read a frame from video stream" << endl;
            break;
        }
        resize(frame,frame,Size(frame.cols/3,frame.rows/3));
        raw_frame = frame;
#if 0
        cvNamedWindow("Original",0); 
        imshow("Original",frame);
#endif

#if 1
        vector<Rect> found, found_filtered;
        Mat human_frame = frame;
        //hog.detectMultiScale(frame, found, 0, Size(8,8), Size(32,32), 1.05, 2);
        hog.detectMultiScale(frame, found, 0, Size(6,6), Size(32,32), 1.05, 2);
        size_t i, j;
        for (i=0; i<found.size(); i++) 
        {
            Rect r = found[i];
            for (j=0; j<found.size(); j++) 
                if (j!=i && (r & found[j]) == r)
                    break;
            if (j== found.size())
                found_filtered.push_back(r);
        }
 
        for (i=0; i<found_filtered.size(); i++) 
        {
            Rect r = found_filtered[i];
            r.x += cvRound(r.width*0.1);
            //r.width = cvRound(r.width*0.8);
            r.width = cvRound(r.width);
            r.y += cvRound(r.height*0.02);
            //r.height = cvRound(r.height*0.8);
            r.height = cvRound(r.height);
            rectangle(human_frame, r.tl(), r.br(), Scalar(0,255,0), 3);        
        }
        imshow("humandetection", human_frame);
#endif


#if 0
        //Changing the contrast and brightness of an image
        /// Do the operation new_image(i,j) = alpha*image(i,j) + beta
        for( int y = 0; y < frame.rows; y++ )
        {   
            for( int x = 0; x < frame.cols; x++ )
            { 
                for( int c = 0; c < 3; c++ )
                {
                    frame.at<Vec3b>(y,x)[c] = saturate_cast<uchar>( alpha*( frame.at<Vec3b>(y,x)[c] ) + beta );
                }
            }
        }
#endif

#if 1

        //update the background model
        pMOG->apply(frame, fgMaskMOG);
        Mat fgMaskMOG_denoise;
        medianBlur(fgMaskMOG, fgMaskMOG_denoise, 5);
        //GaussianBlur( image_seg, fgMaskMOG_denoise, Size( 1, 1 ), 0, 0 );
        imshow("fgMaskMOG_denoise", fgMaskMOG_denoise);
        //pMOG->getBackgroundImage(bkMaskMOG);
        //cvNamedWindow("fgMaskMOG",0); 
        //imshow("fgMaskMOG", fgMaskMOG);
#endif

#if 0        
        cvNamedWindow("bkMaskMOG",0); 
        imshow("bkMaskMOG", bkMaskMOG);
#endif
        
        cvtColor(frame,frame,CV_BGR2GRAY);
        Mat result = frame;
        for(int i=0;i<frame.rows;i++)
        {
            for(int j=0;j<frame.cols;j++)
            {  
    			di1=image.at<uchar>(i,j)-frame.at<uchar>(i,j);
    			di1=absolute_val(di1);
    			if(di1>END)
    			{
    				frame.at<uchar>(i,j)=255;
    			}
    			else 
    			{
    				frame.at<uchar>(i,j)=0;
    			}
            }
        }
        imshow("END_frame", frame);
        Mat frame_denoise;
        medianBlur(frame, frame_denoise, 5);
        //GaussianBlur( frame, frame_denoise, Size( 1, 1), 0, 0 );
        for(int i=0;i<frame.rows;i++)
        {
            for(int j=0;j<frame.cols;j++)
            {  

                if(frame_denoise.at<uchar>(i,j) ==255  || fgMaskMOG_denoise.at<uchar>(i,j) ==255 )
                {
                    result.at<uchar>(i,j) = 255;
                    image_seg.at<Vec3b>(i, j) = raw_frame.at<Vec3b>(i, j);
                }
                else
                {
                    result.at<uchar>(i,j) = 0;
                    image_seg.at<Vec3b>(i, j) = 0;
                }
            }
        }


        imshow("result", result);
        imshow("image_seg", image_seg);

        if (waitKey(30) == 27) //wait for 'esc' key press for 30ms. If 'esc' key is pressed, break loop
        {
            cout << "esc key is pressed by user" << endl;
            break; 
        }
    }
	
	return 0;
}


