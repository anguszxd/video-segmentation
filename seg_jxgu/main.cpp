#include <stdio.h>
#include <iostream>
#include <cmath>
#include <cstdlib>
#include <algorithm>
#include <vector>

#include "opencv2/objdetect/objdetect.hpp"
#include "opencv2/highgui/highgui.hpp"
#include "opencv2/imgproc/imgproc.hpp"
#include <opencv2/video/background_segm.hpp>

#define END 60


using namespace std;
using namespace cv;


void thinningGuoHallIteration(cv::Mat& im, int iter)
{
    cv::Mat marker = cv::Mat::zeros(im.size(), CV_8UC1); 

    for (int i = 1; i < im.rows; i++)
    {
        for (int j = 1; j < im.cols; j++)
        {
            uchar p2 = im.at<uchar>(i-1, j);
            uchar p3 = im.at<uchar>(i-1, j+1);
            uchar p4 = im.at<uchar>(i, j+1);
            uchar p5 = im.at<uchar>(i+1, j+1);
            uchar p6 = im.at<uchar>(i+1, j);
            uchar p7 = im.at<uchar>(i+1, j-1);
            uchar p8 = im.at<uchar>(i, j-1); 
            uchar p9 = im.at<uchar>(i-1, j-1);

            int C  = (!p2 & (p3 | p4)) + (!p4 & (p5 | p6)) +
                     (!p6 & (p7 | p8)) + (!p8 & (p9 | p2));
            int N1 = (p9 | p2) + (p3 | p4) + (p5 | p6) + (p7 | p8);
            int N2 = (p2 | p3) + (p4 | p5) + (p6 | p7) + (p8 | p9);
            int N  = N1 < N2 ? N1 : N2;
            int m  = iter == 0 ? ((p6 | p7 | !p9) & p8) : ((p2 | p3 | !p5) & p4);

            if (C == 1 && (N >= 2 && N <= 3) & m == 0)
                marker.at<uchar>(i,j) = 1;
        }
    }

    im &= ~marker;
}

/**
 * Function for thinning the given binary image
 *
 * @param  im  Binary image with range = 0-255
 */
void thinningGuoHall(cv::Mat& im)
{
    im /= 255;

    cv::Mat prev = cv::Mat::zeros(im.size(), CV_8UC1);
    cv::Mat diff;

    do {
        thinningGuoHallIteration(im, 0);
        thinningGuoHallIteration(im, 1);
        cv::absdiff(im, prev, diff);
        im.copyTo(prev);
    } 
    while (cv::countNonZero(diff) > 0);

    im *= 255;
}



int absolute_val(int a)
{
	if(a>0)
	{
		return a;
	}
	else 
	{
		return -1*a;
	}
}


int main(int argc,char* argv[])
{
    Mat fgMaskMOG, bkMaskMOG; //fg mask generated by MOG method
    Ptr<BackgroundSubtractorMOG2> pMOG; //MOG2 Background subtractor

    //create Background Subtractor objects
    pMOG = createBackgroundSubtractorMOG2(); //MOG2 approach

    VideoCapture cap(argv[1]); // open the video camera no. 0

    if (!cap.isOpened())  // if not success, exit program
    {
        cout << "Cannot open the video cam" << endl;
        return -1;
    }

    double dWidth = cap.get(CV_CAP_PROP_FRAME_WIDTH); //get the width of frames of the video
    double dHeight = cap.get(CV_CAP_PROP_FRAME_HEIGHT); //get the height of frames of the video

    cout << "Frame size : " << dWidth << " x " << dHeight << endl;

    Mat image,image1;
    
    cap.read(image);
    resize(image,image,Size(image.cols/3,image.rows/3));
    cvtColor(image,image,CV_BGR2GRAY);

    //equalizeHist(image,image1);
    cout<<image.channels()<<endl;

    while (1)
    {
        int K=0;
        Mat frame,diff,frame2;
        int di1,di2,di3;


        bool bSuccess = cap.read(frame); // read a new frame from video
        if (!bSuccess) //if not success, break loop
        {
            cout << "Cannot read a frame from video stream" << endl;
            break;
        }
        resize(frame,frame,Size(frame.cols/3,frame.rows/3));

        //update the background model
        pMOG->apply(frame, fgMaskMOG);
        pMOG->getBackgroundImage(bkMaskMOG);

        imshow("FG Mask MOG", fgMaskMOG);
        imshow("BK Mask MOG", bkMaskMOG);

        cvtColor(frame,frame,CV_BGR2GRAY);
        equalizeHist(frame,frame2);
        imshow("Original",frame);
        for(int i=0;i<frame.rows;i++)
        {
            for(int j=0;j<frame.cols;j++)
            {  


    			di1=image.at<uchar>(i,j)-frame.at<uchar>(i,j);
    			di1=absolute_val(di1);
    			if(di1>END)
    			{
    				frame.at<uchar>(i,j)=255;
    			}
    			else 
    			{
    				frame.at<uchar>(i,j)=0;
    			}
    		}
        }

		Mat dis;

		erode(frame, dis, getStructuringElement(MORPH_ELLIPSE, Size(4,4)) );	
		dilate( frame, dis, getStructuringElement(MORPH_ELLIPSE, Size(7, 7)) ); 

		imshow("MyVideo2", frame);

        if (waitKey(30) == 27) //wait for 'esc' key press for 30ms. If 'esc' key is pressed, break loop
        {
            cout << "esc key is pressed by user" << endl;
            break; 
        }
    }
	
	return 0;
}


